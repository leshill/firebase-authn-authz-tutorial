# firebase-authn-authz-tutorial

React/Redux with Firebase authentication and authorization TypeScript tutorial

# Introduction

This tutorial will walk you through building a React app that will use Firebase
Authentication and Firebase Functions to show you how to structure and manage
authentication and authorization in your own Firebase apps.

On the client-side, the tutorial will focus on how to handle the authorization
state, and how to use that to present your user interface. And on the
server-side, the tutorial will focus on how Firebase Authentication can be used
to secure your data and APIs.

In order to demonstrate the concepts, the app will have the following:

* A landing page with sign-up and sign-in links
* A home page
* A sign-up page
* A sign-in page
* A sign-out link
* An admin page to show the list of users
* An API built with Firebase Functions to retrieve the list of users

The tutorial is entirely contained within this **GitHub** repository as a series of
step-wise commits. As you work through the tutorial, partial code snippets are
also directly linked with the related commits for your reference.

As an example, this is the initial commit:

Changeset: [c700afa](https://github.com/leshill/firebase-authn-authz-tutorial/commit/c700afa)

To view the initial commit via the git command line, use the following command:

`git show c700afa`

You can clone this repository via the git command line like so:

`git clone git@github.com:leshill/firebase-authn-authz-tutorial.git`

This is not production code. There are no tests. The app has very limited
functionality. There is absolutely no styling.

# Prerequisites

You should already have a Firebase account setup, if you have not yet done so,
follow the first two steps in this
[guide](https://firebase.google.com/docs/web/setup).

Some familiarity with TypeScript, React, and Redux is expected. Additionally,
the app uses [Redux Toolkit](https://redux-toolkit.js.org/) and [React
Router](https://reacttraining.com/react-router/web/guides/quick-start).

This tutorial was originally built with **Yarn** v1.22.0 running on **Node**
v13.8.0.

# A simple React app without authentication

You will build the initial structure of the app using React to define four main
components: `<App>`, `<Navigation>`, `<Home>`, `<Landing>`.

Begin by using `yarn` to create a new React app skeleton using TypeScript:

`yarn create react-app firebase-authn-authz-tutorial --template typescript`

Check that the app was created successfully with:

`yarn start`

You can leave `yarn` running.

Changeset: [e9e9c5f](https://github.com/leshill/firebase-authn-authz-tutorial/commit/e9e9c5f)

Add Redux Toolkit and React Router libraries to the app:

`yarn add react-redux @types/react-redux @reduxjs/toolkit react-router-dom
    @types/react-router-dom`

Changeset: [9e5deff](https://github.com/leshill/firebase-authn-authz-tutorial/commit/9e5deff)

The generated code (generated by the `yarn create react-app` step) can serve the app with
`https` locally by setting the `HTTPS` variable in the environment. The app will
read in the environment variables from the files `.env` and `.env.local` (and
others) in order. By convention, the `.env` file is checked into source control
and the `.env.local` file is ignored to allow for local overrides.

Turn on `https` support by creating a new file `.env` containing the following:

```
HTTPS=true
```

[What's the problem with using relative paths? Might be worth briefly stating why we make this change.]
The compiler should be able to use absolute imports, minimizing the use of
relative paths when importing files. The TypeScript compiler can be configured
to find imports in the `src` directory. For example, this import:

```ts
import Navigation from "Navigation";
```

will find and import the file `src/Navigation.ts`;

Enable absolute imports by editing the file `tsconfig.json` and add an entry to
the `compilerOptions` hash for `baseUrl`:

```json
{
  "compilerOptions": {
    // ...generated options
    "jsx": "react",
    "baseUrl": "src"
  },
  "include": [
    "src"
  ]
}
```

[Your changeset also had a stanza called "exclude" added that did not show up in my diff as of this step.]
Changeset: [c886b61](https://github.com/leshill/firebase-authn-authz-tutorial/commit/c886b61)

Now you are ready to create a basic React app skeleton that you will build on.
The skeleton will need a landing page and a home page, with routes for each, and
a default route that will go to the landing page. Additionally, the app will
have a navigation header with links to those pages.

Define the routes in the `src/App.tsx` file inside a `<Switch>` component to
ensure that only the matching route is rendered. Also implement the
`<Navigation>`, `<Home>`, and `<Landing>` components.

```ts
  return (
    <BrowserRouter>
      <div>
        <header>
          <Navigation/>
        </header>
        <div>
          <Switch>
            <Route exact path="/home" component={Home}/>
            <Route exact path="/landing" component={Landing}/>
            <Redirect from="/*" to="/landing"/>
          </Switch>
        </div>
      </div>
    </BrowserRouter>
  );
```

Changeset: [f05da61](https://github.com/leshill/firebase-authn-authz-tutorial/commit/f05da61)

Ensure that `yarn` is serving the app, you may need to run `yarn start`. Try the
app out and navigate to the home and landing pages. Try navigating to an
undefined route like `https://localhost:3000/missing`.

# Configure the app for Firebase

The app will need to be configured to connect to your Firebase project. Please
note that none of the configuration is secret, and the values will be visible to
anyone who cares to look at the source of the app in the browser.

The configuration is environment specific, and best practice is to have isolated
environments for development, production, testing, staging, etc... For this app
you will only have one environment. You will save the Firebase configuration in
the `.env.local` file, where it will be picked up by both the local build and
the production build that is deployed to Firebase.

To get started, add the `firebase`, `firebase-admin`, and `firebase-functions`
libraries to the app:

`yarn add firebase firebase-admin firebase-functions`

Changeset: [050a3f8](https://github.com/leshill/firebase-authn-authz-tutorial/commit/050a3f8)

In the Project settings of the Firebase console, find the `Firebase SDK snippet`
and select `Config`. Copy the config snippet and and paste it into a new file
`.env.local` and edit each line to look similar to the following depending on
how you setup the project:
[NIT: should be "set up"]

```
REACT_APP_API_KEY=KEY
REACT_APP_AUTH_DOMAIN=DOMAIN
REACT_APP_DATABASE_URL=URL
REACT_APP_PROJECT_ID=ID
REACT_APP_STORAGE_BUCKET=BUCKET_DOMAIN
REACT_APP_MESSAGING_SENDER_ID=ID
REACT_APP_APP_ID=ID
REACT_APP_MEASUREMENT_ID=ID
```

The app will read the configuration at build time from the environment. Copy the
config snippet again and paste it into a new file `src/FirebaseApp.ts` and edit
it as needed for your project:

```ts
const config = {
  apiKey: process.env.REACT_APP_API_KEY,
  authDomain: process.env.REACT_APP_AUTH_DOMAIN,
  databaseURL: process.env.REACT_APP_DATABASE_URL,
  projectId: process.env.REACT_APP_PROJECT_ID,
  storageBucket: process.env.REACT_APP_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_APP_ID,
  measurementId: process.env.REACT_APP_MEASUREMENT_ID
};

class FirebaseApp {
  constructor() {
    firebase.initializeApp(config);
  }

  config = () => firebase.app().options;
};
```

This file declares a class that will hold all of the Firebase code for the app.
The underlying connection to Firebase is initialized in the constructor.

In order to use Firebase, you will initialize an instance of the `FirebaseApp`
class, save it in a React context, and then reference it from the context.

To make using the React context a little easier, borrow a utility from the
[React+TypeScript
Cheatsheets](https://github.com/typescript-cheatsheets/react-typescript-cheatsheet#context):

Changeset: [c6fb46a](https://github.com/leshill/firebase-authn-authz-tutorial/commit/c6fb46a)

Declare the Firebase context with `useSafeContext`:

```ts
export const [FirebaseContextProvider, useFirebaseContext] =
  useSafeContext<FirebaseApp>();
```


Changeset: [db54647](https://github.com/leshill/firebase-authn-authz-tutorial/commit/db54647)

You can now connect to Firebase by instantiating a `FirebaseApp` in
`src/App.tsx`:

```ts
const firebase = new FirebaseApp();
```

Then set the instance as the value in the `<FirebaseContextProvider>`:

```ts
    <FirebaseContextProvider value={firebase}>
      {/* Context available to components within here */}
    </FirebaseContextProvider>
```

Check your work by using the context in the `<Home>` component:

```ts
const Home: React.FC = () => {
  const firebase = useFirebaseContext();

  return (
    <div>
      <h1>Home</h1>
      <p>
        The app config is {JSON.stringify(firebase.config())}.
      </p>
    </div>
  );
};
```

Changeset: [2dc42b7](https://github.com/leshill/firebase-authn-authz-tutorial/commit/2dc42b7)

Try the app out and verify the updated message from the `<Home>` component.

[I got a module not found error here for "react-router-dom" and had to `yarn add react-router-dom` to fix it.]

# Build the sign-up UI with Firebase

Firebase provides multiple authentication providers, including Google, Facebook,
and others. For this tutorial you will use the `Email/Password` provider. Enable
the provider under the Authentication section of the Firebase console.

To use the `Email/Password` provider, the app will need to provide an email
address and password to sign up a new user.

You will implement a simple React form to gather the email address, password,
and a confirmation password. The form should validate that the email and
password are present, and that the password and confirmation match before
allowing the user to submit the form. Initially, the form submit should just
trigger an alert.

Create a new file `src/SignUp.tsx` and implement the initial `<SignUp>`
component:

```ts
const initialState = {
  email: "",
  passwordOne: "",
  passwordTwo: ""
};

const SignUp: React.FC = () => {
  const [creds, setCreds] = useState(initialState);

  const { email, passwordOne, passwordTwo } = creds;

  const isInvalid = passwordOne !== passwordTwo ||
                    passwordOne === "" ||
                    email === "";

  const onChange = (event: React.FormEvent<HTMLInputElement>) =>
    setCreds({...creds, [event.currentTarget.name]: event.currentTarget.value});

  const onSubmit = (event: React.FormEvent) => {
    alert(`Email: ${email} Password: ${passwordOne}`);
    setCreds(initialState);
    event.preventDefault();
  };

  return (
    <div>
      <h1>Sign Up</h1>
      <form onSubmit={onSubmit}>
        <input
          name="email"
          value={email}
          onChange={onChange}
          type="text"
          placeholder="Email Address"
        />
        <input
          name="passwordOne"
          value={passwordOne}
          onChange={onChange}
          type="password"
          placeholder="Password"
        />
        <input
          name="passwordTwo"
          value={passwordTwo}
          onChange={onChange}
          type="password"
          placeholder="Confirm Password"
        />
        <button disabled={isInvalid} type="submit">Sign Up</button>
      </form>
    </div>
  );
};
```

Put a link to the sign-up page on the landing page, and add an exact route to
`src/App.tsx`.

Changeset: [326cb47](https://github.com/leshill/firebase-authn-authz-tutorial/commit/326cb47)

Navigate to the landing page and click the _Sign Up_ link. Verify that your form
correctly submits the email and password to the alert box.

Instead of just showing an alert when the user submits the form, you will have
the app use the Firebase `createUserWithEmailAndPassword` API to create the
user.

Add a `createUser` method to the `FirebaseApp` class to create the user with
Firebase:

```ts
  createUser = (email: string, password: string) =>
    firebase.auth().createUserWithEmailAndPassword(email, password);
```

**Note:** you must import the Firebase auth library to generate the side-effect
that exposes the API code in the Firebase modules.

```ts
import "firebase/auth";
```

Change the `<SignUp>` component to reference the `FirebaseApp` instance from the
context and invoke `createUser` from the submit handler. Edit `src/SignUp.tsx`:

```ts
  const onSubmit = (event: React.FormEvent) => {
    setCreds({ ...creds, error: null });
    firebase.createUser(email, passwordOne)
            .then(_authUser => {
              setCreds({ ...initialState });
            })
            .catch(error => {
              setCreds({ ...creds, error: error.message });
            });
    event.preventDefault();
  };
```

When the form is submitted, the app will attempt to create the user.

On success, the user will be signed up and the form will be cleared. The
credential returned on success by the Firebase `createUserWithEmailAndPassword`
method is ignored.

On error, the error message is displayed to the user.

Changeset: [64103e3](https://github.com/leshill/firebase-authn-authz-tutorial/commit/64103e3)

As a test, check the Firebase current user in `<Home>`. Edit `src/Home.tsx`:

```ts
      <p>
        {
          firebase.auth.currentUser ?
          firebase.auth.currentUser.email : "Not signed in"
        }
      </p>
```

Changeset: [ff012e5](https://github.com/leshill/firebase-authn-authz-tutorial/commit/ff012e5)

Try the form out using a malformed email such as `not-an-email.com`.

Use the form to create a valid user and see the user show up as a new user in
the Authentication section of the Firebase console. You will notice that the
user remains on the sign-up page after signing up; you will learn how to manage
the app's signed in state with Redux later in the tutorial.

Verify that the current user is signed in by navigating to the home page.

# Build the sign-out UI with Firebase

Now that the user has been created and is signed in, add a sign out link to the
app.

Edit `src/Navigation.tsx` and add a link that triggers an alert.

```ts
const Navigation: React.FC = () => {
  const onSignOutClicked = (event: React.MouseEvent) => {
    alert("Sign out clicked");
    event.preventDefault();
  };

  return (
    <div>
      <ul>
        <li>
          <Link to="/home">
            Home
          </Link>
        </li>
        <li>
          <Link to="/landing">
            Landing
          </Link>
        </li>
        <li>
          <a href="#sign_out" onClick={onSignOutClicked}>
            Sign Out
          </a>
        </li>
      </ul>
    </div>
  );
};
```

Changeset: [1806c4e](https://github.com/leshill/firebase-authn-authz-tutorial/commit/1806c4e)

Verify that clicking the link will generate an alert.

Add a `signOut` method to the `FirebaseApp` class to actually sign the user out:

```ts
  signOut = () => this.auth.signOut();
```

Change the `<Navigation>` component to reference the `FirebaseApp` instance from
the context and invoke the new `signOut` method from the click handler. Edit
`src/SignUp.tsx`:

```ts
  const onSignOutClicked = (event: React.MouseEvent) => {
    firebase.signOut();
    event.preventDefault();
  };
```

Changeset: [93abe7c](https://github.com/leshill/firebase-authn-authz-tutorial/commit/93abe7c)

Try it and verify that the current user is signed out by navigating to the home page.

# Build the sign-in UI with Firebase

The user can sign up and sign out, now they need a way to sign in with the
account they created.

Like `<SignUp>`, you will create a simple React form that validates that the
user has entered an email and password. When submitted, the form should trigger
an alert. Create a new file `src/SignIn.tsx`:

```ts
const initialState = {
  email: "",
  password: ""
};

const SignIn: React.FC = () => {

  const [creds, setCreds] = useState(initialState);

  const { email, password } = creds;

  const isInvalid = password === "" ||
                    email === "";

  const onChange = (event: React.FormEvent<HTMLInputElement>) => {
    setCreds({...creds, [event.currentTarget.name]: event.currentTarget.value});
  }

  const onSubmit = (event: React.FormEvent) => {
    alert(`Sign in with email: ${email} password: ${password}`);
    event.preventDefault();
  };

  return (
    <div>
      <h1>Sign In</h1>
      <form onSubmit={onSubmit}>
        <input
          name="email"
          value={email}
          onChange={onChange}
          type="text"
          placeholder="Email Address"
        />
        <input
          name="password"
          value={password}
          onChange={onChange}
          type="password"
          placeholder="Password"
        />
        <button disabled={isInvalid} type="submit">Sign Up</button>
      </form>
    </div>
  );
};
```

Add a link to the sign-in page from the landing page, and add an exact route to
`src/App.tsx`.

Changeset: [1b3a308](https://github.com/leshill/firebase-authn-authz-tutorial/commit/1b3a308)

Navigate to _Sign In_ and verify that your form correctly submits the email and
password to the alert box.

When the user submits the form, the app will use the Firebase
`signInWithEmailAndPassword` API to sign in the user.

Add a `signIn` method to the `FirebaseApp` class to sign the user in with
Firebase:

```ts
  signIn = (email: string, password: string) =>
    firebase.auth().signInWithEmailAndPassword(email, password);
```


Change the `<SignIn>` component to reference the `FirebaseApp` instance from the
context and invoke `signIn` from the submit handler. Edit `src/SignIn.tsx`:

```ts
  const onSubmit = (event: React.FormEvent) => {
    setCreds({ ...creds, error: null });
    firebase.signIn(email, password)
            .then(_authUser => {
              setCreds({ ...initialState });
            })
            .catch(error => {
              setCreds({ ...creds, error: error.message });
            });
    event.preventDefault();
  };
```

On success, the user will be signed up and the form will be cleared. The
credential returned on success by the Firebase `signInWithEmailAndPassword`
method is ignored.

The user remains on the sign-in page after signing in; you will manage the app's
signed in state with Redux next.

On error, the error message is displayed to the user.

Changeset: [823de9b](https://github.com/leshill/firebase-authn-authz-tutorial/commit/823de9b)

Sign out, then attempt to sign in. Verify that the user is signed in on the home
page.

# Use Redux to manage the current user

All the pieces needed to manage the authentication state with Redux are now in place.
You will create a Redux _slice_ to manage the state of the current user in the
app.

**Nomenclature digression:** A _slice_ is Redux-speak for state and associated
code for one specific sub-tree of the state tree. For example, the app will
track the current user in the `auth` _slice_. From a code perspective, when
looking at the state object, the `auth` _slice_ is the sub-tree returned by
the expression `state.auth`.

Redux requires a bit of boilerplate to setup. First, create a Redux reducer
placeholder in a new file `src/rootReducer.ts`:

```ts
import { combineReducers } from "@reduxjs/toolkit";

const rootReducer = combineReducers({
});

export type RootState = ReturnType<typeof rootReducer>;

export default rootReducer;
```

Create the Redux store in a new file `src/store.ts`:

```ts
import { configureStore } from "@reduxjs/toolkit";
import rootReducer from "rootReducer";

const store = configureStore({
  reducer: rootReducer
});
```

Then reference and use the store in `src/App.tsx`:

```ts
function App() {
  return (
    <Provider store={store}>
      {/* Store available here */}
    </Provider>
  );
}
```

Changeset: [6a0dd99](https://github.com/leshill/firebase-authn-authz-tutorial/commit/6a0dd99)

Redux Toolkit allows you to easily combine the state and code for a _slice_ using
the kitchen-sink API `createSlice`. Create the `auth` _slice_ in the new file
`src/authSlice.ts`:

```ts
type AuthState = {
  currentUser: any | null
};

const initialState: AuthState  = {
  currentUser: null
};

const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    userChanged(state, action: PayloadAction<any | null>) {
      state.currentUser = action.payload;
    }
  }
});

export const {
  userChanged
 } = authSlice.actions;

export default authSlice.reducer;
```

To add the `auth` _slice_ to the app's Redux store, add the `auth` reducer into
`src/rootReducer.ts`:

```ts
import authReducer from "authSlice";

const rootReducer = combineReducers({
  auth: authReducer
});
```

Changeset: [c4426fc](https://github.com/leshill/firebase-authn-authz-tutorial/commit/c4426fc)

The current user is now part of the state in the Redux store and can be used by
the UI. Edit `src/Navigation.tsx` and split the links in the `<Navigation>`
component into authenticated and unauthenticated lists:

```ts
const Navigation: React.FC = () => {
  const currentUser = useSelector((state: RootState) => state.auth.currentUser);

  if (currentUser) {
    return (
      <div>
        <Authenticated/>
      </div>
    );
  } else {
    return (
      <div>
        <Unauthenticated/>
      </div>
    );
  }
};
```

Changeset: [6ce4179](https://github.com/leshill/firebase-authn-authz-tutorial/commit/6ce4179)

The initial state of the `auth` slice is a `null` current user. Verify that the
`<Navigation>` component is showing the unauthenticated links.

When a current user is present in the Redux store, the `<Navigation>` component
will show the authenticated links. To demonstrate this, dispatch the
`userChanged` event to Redux from the sign-in form to set a dummy current user
in the Redux store. Make this temporary change in `src/SignIn.tsx`:

```ts
  const onSubmit = (event: React.FormEvent) => {
    setError(null);
    firebase.signIn(email, password)
            .then(_authUser => {
              dispatch(userChanged({name: "sign-in"}));
              setCreds({ ...initialState });
            })
            .catch(error => {
              setError(error);
            });
    event.preventDefault();
  };
```

Changeset: [efb71ff](https://github.com/leshill/firebase-authn-authz-tutorial/commit/efb71ff)

Sign in to the app and the `<Navigation>` component will re-render with the
authenticated links.

Revert the change; if you are using the command line, use `git revert head`.

Changeset: [c05de7f](https://github.com/leshill/firebase-authn-authz-tutorial/commit/c05de7f)

Instead of having to track every use of the Firebase Authentication API
throughout the app, Firebase provides a method to register a handler that will
be notified when the authentication state changes.

Create a method `trackAuthStateChanged` in `FirebaseApp` to register a handler
with `onAuthStateChanged`. This handler will dispatch to the Redux store when
the authentication state changes.

The return from `onAuthStateChanged` is a cancel callback that can be used to
unregister the handler.

Edit `src/FirebaseApp.ts` and implement `trackAuthStateChanged`:

```ts
  trackAuthStateChanged = (dispatch: Dispatch) =>
    firebase.auth().onAuthStateChanged((user: firebase.User | null) => {
      if (user) {
        dispatch(userChanged(user.toJSON()));
      } else {
        dispatch(userChanged(null));
      }
    });
```

When Firebase invokes the handler, the appropriate `userChanged` event is
dispatched to Redux to update the current user.

Changeset: [d0c9ae8](https://github.com/leshill/firebase-authn-authz-tutorial/commit/d0c9ae8)

`trackAuthStateChanged` could be used by the app to manage the current user in a
few ways:

* by using a component `<TrackAuth>`
* by using a HOC (higher order component)
* by using a custom hook

For this app, you will use a component. The component will register the handler
when initially rendered, and then unregister the handler when the component is
unmounted.

Create the component in a file `src/TrackAuth.tsx`:

```ts
const TrackAuth: React.FC = ({ children }) => {
  const dispatch = useDispatch();
  const firebase = useFirebaseContext();

  useEffect(() => {
    const cancelListener = firebase.trackAuthStateChanged(dispatch);

    return () => {
      cancelListener();
    }
  }, [dispatch, firebase]);

  return (
    <React.Fragment>
      { children }
    </React.Fragment>
  );
};
```

The `useEffect` hook registers the handler when initially rendered, and will
unregister the handler when the `<TrackAuth>` component is unmounted.

Changeset: [b3dd717](https://github.com/leshill/firebase-authn-authz-tutorial/commit/b3dd717)

Use `<TrackAuth>` from the `<App>` component to cover the life-cycle of the
entire app. Edit `src/App.tsx`:

```ts
function App() {
  return (
    <Provider store={store}>
      <FirebaseContextProvider value={firebase}>
        <TrackAuth>
          {/* ... */}
        </TrackAuth>
      </FirebaseContextProvider>
    </Provider>
  );
}
```

Changeset: [d10f8a7](https://github.com/leshill/firebase-authn-authz-tutorial/commit/d10f8a7)

Now that the current user's status is available in the `auth` _slice_, you can
have a successful sign in redirect the user to the `<Home>` page.

You will do this with a HOC that will wrap the `<SignIn>` component and redirect
to `<Home>` or render `<SignIn>` based on the authentication status being
signed-in or not.

Create the new HOC in `src/signedOutOnly.tsx`:

```ts
const signedOutOnly: <P extends object>(Wrapped: React.ComponentType<P>) =>
  React.FC<P> =
    (Wrapped) => {
      // <eye-roll>
      // TypeScript linter error with direct return:
      // React Hook "useSelector" cannot be called inside a callback. React Hooks
      // must be called in a React function component or a custom React Hook function
      // react-hooks/rules-of-hooks
      //
      // TypeScript linter error without Capitalized name:
      // React Hook "useSelector" is called in function "wrapper" which is neither a
      // React function component or a custom React Hook function
      // </eye-roll>
      const Wrapper = (props: any) => {
        const currentUser = useSelector((state: RootState) => state.auth.currentUser);

        if (currentUser) {
          return (
            <Redirect to="/home"/>
          );
        } else {
          return (
            <Wrapped {...props} />
          );
        }
      };
      return Wrapper;
    };
```

_Note that this code is more verbose than necessary in order to satisfy the
TypeScript linter._

Changeset: [4ae6753](https://github.com/leshill/firebase-authn-authz-tutorial/commit/4ae6753)

Use the HOC to wrap the `<SignIn>` component and give it the desired behavior.
Edit `src/SignIn.tsx`:

```ts
export default signedOutOnly(SignIn);
```

Changeset: [08c5a1b](https://github.com/leshill/firebase-authn-authz-tutorial/commit/08c5a1b)

Try signing out and signing back in to see the effect on the `<SignIn>`
component.

You should now add the new behavior to the `<SignUp>` component.

Changeset: [b2fa709](https://github.com/leshill/firebase-authn-authz-tutorial/commit/b2fa709)

**Security Caveat:** By having the current user in the Redux store, the app can
easily determine the authentication and authorization status of the user and use
that data to show the appropriate user interface. You should not depend on it
for other security concerns as code in the browser is easily subverted. The
tutorial will cover more of this later.

# Making it nicer: persisting the current user with local storage

[I like this part; this is the kind of thing usually ommitted by tutorials.]
One drawback to using Firebase authentication is that accessing the current user
depends on Firebase being initialized and connected. This can lead to a
**FOU13DC** (_flash of unauthenticated content_).

To see the **FOU13DC**, edit `src/FirebaseApp.ts` and delay the update to the
current user:

```ts
  trackAuthStateChanged = (dispatch: Dispatch) =>
    firebase.auth().onAuthStateChanged((user: firebase.User | null) => {
      if (user) {
        setTimeout(() => dispatch(userChanged(user.toJSON())), 3000);
      } else {
        dispatch(userChanged(null));
      }
    });
```

Changeset: [25cd991](https://github.com/leshill/firebase-authn-authz-tutorial/commit/25cd991)

Ensure you are signed in. Refresh the page to reload the code. Click on the
`Sign In` navigation link and wait for the delay to expire. You should see that
the `<SignIn>` component renders, then eventually redirects to `<Home>`.

The app can use local storage to save the current user when Redux updates the
`auth` _slice_. While waiting for Firebase to be connected, the last known state
of the current user can be used to initialize the `auth` _slice_.

Edit `src/authSlice.ts`, and mirror changes from Redux to local storage:

```ts
const currentUser ="currentUser";

function getLocalCurrentUser() {
  let value = localStorage.getItem(currentUser);

  if (value) {
    value = JSON.parse(value);
  }

  return value;
}

const initialState: AuthState  = {
  currentUser: getLocalCurrentUser()
};

const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    userChanged(state, action: PayloadAction<any | null>) {
      state.currentUser = action.payload;
      try {
        if (action.payload) {
          localStorage.setItem(currentUser, JSON.stringify(action.payload));
        } else {
          localStorage.removeItem(currentUser);
        }
      }
      catch (error) {
        console.log("localStorage error:", error);
      }
    }
  }
});
```

Changeset: [022c9f8](https://github.com/leshill/firebase-authn-authz-tutorial/commit/022c9f8)

To view the new behavior, ensure you are signed in. Navigate to the landing page
which has the `Sign In` link. Refresh the page to reload the code. Click on the
`Sign In` navigation link and you should immediately be redirected to the home
page.

This approach does have an edge case, as the user may have signed in long ago
and still be present in local storage. Firebase will detect that the user's
session has expired when it has connected. On first load, the user would appear
to be signed-in, and on connecting would immediately sign out the user. Covering
that case is left as an exercise.

Revert the previous change with the delay; if you are using the command line,
use `git revert head~`.

Changeset: [41f380f](https://github.com/leshill/firebase-authn-authz-tutorial/commit/41f380f)

The app now has basic user authentication in place, allowing users to sign up,
sign in, and sign out. Of course, your app will need additional features such as
changing the password, email verification, etc... Implementing these features is
left as an exercise.

# Configure the app for Firebase Functions

Firebase Functions are code that is managed separately from your app code. It is
usually located in the `functions` subdirectory and deployed on its own to
Firebase, where it is scaled and managed for you automatically.

Firebase Functions can be invoked as an API from server-side or client-side code,
as an HTTPS service, and by Firebase itself with triggers.

Firebase triggers are callbacks from Firebase services such as the Firebase
Authentication service which can invoke a Firebase Function after creating a
user.

Some setup is required to create the Functions application that will be deployed
to Firebase.

Start by ignoring the file `.firebaserc` in `.gitignore`.

Changeset: [c866c33](https://github.com/leshill/firebase-authn-authz-tutorial/commit/c866c33)

Install `firebase-tools` to get the Firebase CLI:

[Why npm here instead of yarn, is yarn not an option?]
`npm install -g firebase-tools`

Sign in to Firebase via the CLI:

`firebase login`

Use the CLI to initialize Firebase Functions in the app, which will ask some
questions during the setup. Run the command:

`firebase init functions`

Answer the questions:

* Use your existing project
* Use TypeScript
* Configure TSLint
* Do not run `npm`

At this point, your project directory has the necessary files to deploy a
skeleton Firebase Functions app. Commit the `firebase.json` file and the
`functions` directory.

Changeset: [277b0f2](https://github.com/leshill/firebase-authn-authz-tutorial/commit/277b0f2)

Change the Functions runtime from the default to use Node v10.16.2, which is the
latest version available at the time this was written. Edit
`functions/package.json`:

```json
  "engines": {
    "node": "10"
  },
```

Tweak the TypeScript settings, edit `functions/tsconfig.json`:

```json
  "compilerOptions": {
    "module": "commonjs",
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "outDir": "lib",
    "sourceMap": true,
    "strict": true,
    "target": "es2017",
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true
  },
```

Use yarn to install the dependencies for the Firebase Functions in the
`functions` directory:

`cd functions; yarn install; cd ..`

Changeset: [86ab02b](https://github.com/leshill/firebase-authn-authz-tutorial/commit/86ab02b)

You have completed the Firebase Functions setup for your project, and can now
implement the API you will need for the Admin UI.

# Building an Admin UI

You will implement an Admin role for the app, allowing admins to view a list of
users and then toggle the Admin role for a user.

Firebase Admin supports defining custom claims on Firebase Authentication user
accounts. Custom claims can be used to implement access controls for the backend
services of your app, for example Firestore or Firebase Functions.

For this tutorial, the custom claim will be a boolean claim named `admin` that
is set to `true` if the user has the Admin role.

Replace the code in `src/functions/index.ts` to initialize Firebase Admin for
your Firebase Functions:

```ts
import * as admin from "firebase-admin";
import "firebase-functions";

admin.initializeApp();
```

**Note:** The second import is used for its side-effect only, similar to the
`firebase/auth` import you added earlier.

Changeset: [059f32b](https://github.com/leshill/firebase-authn-authz-tutorial/commit/059f32b)

To bootstrap the Admin role, the app will recognize a particular email as being
an admin. The user with that email will be given the Admin role and be able to
update the admin status of other users.

Choose an email for your admin user and set it in the environment configuration
for Firebase Functions:

`firebase functions:config:set admin.default_email=your-email-here`

Check it with:

`firebase functions:config:get`

To bootstrap that admin, implement the `onCreate` trigger from Firebase
Authentication in `src/functions/index.ts`:

```ts
function setCustomUserClaims(uid: string, claims: any): Promise<void> {
  return admin.auth().setCustomUserClaims(uid, claims);
}

export const onCreate = functions.auth.user()
  .onCreate((user: admin.auth.UserRecord): Promise<void> => {
    const defaultEmail = functions.config().admin.default_email;

    if (user.email === defaultEmail &&
        user.providerData.length === 1 &&
        user.providerData[0].providerId === "password") {
      return setCustomUserClaims(user.uid, {admin: true});
    } else {
      return Promise.resolve();
    }
  });
```

The `onCreate` trigger will run for each user created by Firebase. If the user is
being created by the `Email/Password` sign-in provider and has an email that
matches the configured default admin email, the admin claim is set on the user.

Changeset: [8d0230b](https://github.com/leshill/firebase-authn-authz-tutorial/commit/8d0230b)

At the moment, there does not appear to be a way to view custom claims in the
Firebase console. Instead display the Admin role for the current user on the
home page. Edit `src/Home.tsx`:

```ts
  const [admin, setAdmin] = useState(false);

  useEffect(() => {
    const user = firebase.auth.currentUser;
    if (user) {
      user.getIdTokenResult().then((idToken) => {
        setAdmin(idToken.claims.admin);
      });
    }
  }, [firebase.auth.currentUser]);
```

```ts
      <p>
        User is { admin ? "" : "not"} an admin
      </p>
```

Changeset: [a1951b7](https://github.com/leshill/firebase-authn-authz-tutorial/commit/a1951b7)

# Deploy Firebase Functions

The app is ready to create the default admin. Deploy your Firebase Functions app
from the CLI:

`firebase deploy --only functions`

Once the deploy is complete, the Functions section of the Firebase console will
show the `onCreate` trigger.

To test the trigger, you will sign up with the default admin email. If you have
previously used that email to create a user, go to Authentication section of the
Firebase console and delete the user.

Sign up with the default admin email. When you check the home page the user will
not have the Admin role. You will have to sign out and sign in to reload the
current user as the trigger has taken effect after Firebase authenticated and
authorized the user. For details on this behavior, check the Firebase
Authentication [docs](https://firebase.google.com/docs/auth).

# Showing the list of users to Admins

To demonstrate the use of authorization with Firebase, the app will have an
Admin UI to show the list of users in Firebase.

The app will get the list of users from an API implemented as a callable
Firebase Function. The API will need to verify the caller's credentials as the
client-side code cannot be trusted. Any request coming into your Firebase
Functions will need to make the appropriate authentication and authorization
checks.

For callable API functions, the _context_ parameter will have the credentials
available, HTTPS API functions should extract the credentials from the request,
and triggers may or may not have credentials available depending on the trigger.

To show the list of users, you will verify that the calling user has the Admin
role. Once verified, the list of users can be retrieved.

Edit `src/functions/index.ts` and implement `listUsers`:

```ts
export const listUsers = functions.https.onCall(
  async (
    _data: any,
    context: functions.https.CallableContext
  ): Promise<any[]> => {
    validateAdmin(context);

    return admin.auth()
      .listUsers()
      .then((listUsersResult: admin.auth.ListUsersResult) => {
        const users: any[] = [];

        listUsersResult.users.forEach((userRecord: admin.auth.UserRecord) => {
          users.push(fromAdminRecord(userRecord));
        });

        return users;
      })
      .catch((error) => {
        throw new functions.https.HttpsError("internal", error.message);
      });
  });
```


Changeset: [95aec73](https://github.com/leshill/firebase-authn-authz-tutorial/commit/95aec73)

Use the CLI to deploy the `listUsers` API:

`firebase deploy --only functions`

To use the API, expose the `listUsers`callable function in the `FirebaseApp`
class, edit `src/FirebaseApp.ts`:

```ts
  listUsers: firebase.functions.HttpsCallable;

  constructor() {
    firebase.initializeApp(config);

    this.auth = firebase.auth();
    this.listUsers = firebase.functions().httpsCallable("listUsers");
  }
```

Changeset: [935499e](https://github.com/leshill/firebase-authn-authz-tutorial/commit/935499e)

The `<Admin>` component will show the list of users. To demonstrate that the
validation check in the API is working, you will add the link to the `<Admin>`
component and always display it if the user is authenticated (Admin role not
required). You can then verify that only users with the Admin role can
successfully call into the `listUsers` API.

Create `src/Admin.tsx` with a basic `<Admin>` component and add it to the
authenticated links of `<Navigation>`.

Changeset: [d8e9be5](https://github.com/leshill/firebase-authn-authz-tutorial/commit/d8e9be5)

Use the `listUsers` method and local React state in the `<Admin>` component to
manage the list of users. Implement the list in `src/Admin.tsx`:

```ts
const Admin: React.FC = () => {
  const firebase = useFirebaseContext();

  const [state, setState] = useState({
    error: null as string | null,
    users: [] as any[]
  });
  const {error, users} = state;

  useEffect(() => {
    firebase.listUsers().then((result: firebase.functions.HttpsCallableResult) => {
      setState({
        error: null,
        users: result.data
      });
    }).catch((error: {message: string}) => {
      setState({
        error: error.message,
        users: []
      });
    });
  }, [firebase]);

  return (
    <div>
      <h1>Admin: Users list</h1>
      { error && <p>{error}</p> }
      <ul>
        {
          users.map(
            user => (
              <li key={user.uid}>
                <ul>
                  <li>
                    Email: {user.email}
                  </li>
                  <li>
                    Admin: {user.customClaims.admin ? "true" : "false"}
                  </li>
                </ul>
              </li>
            )
          )
        }
      </ul>
    </div>
  );
};
```

Changeset: [ceaa5b3](https://github.com/leshill/firebase-authn-authz-tutorial/commit/ceaa5b3)

Try it by navigating to the `<Admin>` component.

When you are signed in with a user that has the Admin role, then you will see a
list of users as returned from the `listUsers` API.

When you are signed in with a user without the Admin role, you will see the
error message generated by the `listUsers` API: _This API must be called while
authenticated as an admin._

# Toggling the Admin role

The last part of the tutorial will add an Admin role toggle for the list of
users shown in `<Admin>`.

You will write the `toggleAdmin` callable API and verify that the calling user has
authorization to toggle the Admin role. Once verified, toggle the `admin` custom
claim on for the specified user.

Add `toggleAdmin` to `src/functions/index.ts`:

```ts
export const toggleAdmin = functions.https.onCall(
  async (
    data: any,
    context: functions.https.CallableContext
  ): Promise<void> => {
    validateAdmin(context);

    if (!data.uid || !data.hasOwnProperty("admin")) {
      throw new functions.https.HttpsError(
        "failed-precondition",
        "missing parameter"
      );
    } else {
      return reloadUser(data.uid).then((user: admin.auth.UserRecord) => {
        const claims: any = user.customClaims || {};

        if (claims.admin && !data.admin) {
          delete claims.admin;
        } else if (!claims.admin && data.admin){
          claims.admin = true;
        } else {
          // Already set
          return Promise.resolve();
        }

        return setCustomUserClaims(data.uid, claims);
      });
    }
  });
```

Note that the `toggleAdmin` API requires both an `admin: boolean` and `uid:
string` as parameters.

Changeset: [8fa4821](https://github.com/leshill/firebase-authn-authz-tutorial/commit/8fa4821)

Use the CLI to deploy the `toggleAdmin` API:

`firebase deploy --only functions`

Make the API available to your app by exposing the `toggleAdmin`callable
function in the `FirebaseApp` class. Edit `src/FirebaseApp.ts`:

```ts
  constructor() {
    firebase.initializeApp(config);

    this.auth = firebase.auth();
    this.listUsers = firebase.functions().httpsCallable("listUsers");
    this.toggleAdmin = firebase.functions().httpsCallable("toggleAdmin");
  }
```

Changeset: [a1432ee](https://github.com/leshill/firebase-authn-authz-tutorial/commit/a1432ee)

Simplify the `<Admin>` component by extracting the user display into a `<User>`
component. For this app, keep the toggling logic in `<Admin>` and create a
callback that can be passed to each `<User>`.

To enforce updating only a single user at a time, manage an `<Admin>` scoped
`enabled` flag to disable toggling while another toggle is in progress.

Make these changes to `src/Admin.tsx`:

```ts
const User: React.FC<{ user: any,
                       enabled: boolean,
                       toggle: (admin: boolean, user: any) => void }> =
  ({ user, enabled, toggle }) => {
    const toggleAdminRole = (event: React.ChangeEvent<HTMLInputElement>) => {
      toggle(event.target.checked, user);
      event.preventDefault();
    }

    return (
      <li>
        <ul>
          <li>
            Email: {user.email}
          </li>
          <li>
            <form>
              <label>
                Admin{}:
                <input
                  disabled={!enabled}
                  name="isAdmin"
                  type="checkbox"
                  checked={user.customClaims.admin ? true : false}
                  onChange={toggleAdminRole}
                />
              </label>
            </form>
          </li>
        </ul>
      </li>
    );
  }
```

```ts
  const [state, setState] = useState({
    enabled: true,
    error: null as string | null,
    users: [] as any[]
  });
  const {enabled, error, users} = state;

  const toggleAdmin = (admin: boolean, user: any) => {
    setState({
      ...state,
      enabled: false,
      error: null
    });
    firebase.toggleAdmin({ admin: admin, uid: user.uid }).then(() => {
      const updatedUsers = users.map((u) => {
        if (u.uid === user.uid) {
          if (admin) {
            user.customClaims.admin = true;
          } else {
            delete user.customClaims.admin;
          }
          return user;
        } else {
          return u;
        }
      });

      setState({
        ...state,
        enabled: true,
        users: updatedUsers
      });
    }).catch((error) => {
      setState({
        ...state,
        enabled: true,
        error: error.message
      });
    });
  };
```

```tsx
      <ul>
        { users.map(
            (user) =>
              (<User key={user.uid}
                     user={user}
                     enabled={enabled}
                     toggle={toggleAdmin}
              />)
        )}
      </ul>
```

Changeset: [ab56c30](https://github.com/leshill/firebase-authn-authz-tutorial/commit/ab56c30)

Try toggling the admin status. If you toggle the admin role for the signed in
user, the admin status of user will not change. Signing out and signing back in
removes the admin status. For details on this behavior, check the Firebase
Authentication [docs](https://firebase.google.com/docs/auth).

# Summary

This tutorial showed you how to setup, structure, and use authentication and
authorization for your Firebase project using React and Redux.

Use Firebase Authorization to make decisions about what parts of the UI are
shown and what actions the user can take. Understand that the client-side code
can be easily subverted and cannot be trusted to provide any actual security.

In your server-side code, such as Firebase Functions or security rules for
Firestore (another topic), you should always verify the users credentials before
taking any actions.

[Love that this is reiterated :)]
Remember that the client-side code can be easily subverted and cannot be trusted
to provide any actual security. Always secure the server-side code.

# Changes, fixes, and comments

If you find a bug, have a fix, or just want to comment or suggest
something, please open an issue on **GitHub**.

If you are making changes to the **README**, edit `README.src.md`. Run the
`bin/readme-cset` command (requires relatively current **Ruby**) to generate
`README.md`:

`bin/readme-cset README.src.md > README.md`
